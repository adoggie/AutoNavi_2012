# -*- coding:utf-8 -*-#2012.2.3 scott   #转换 gs600行车记录仪 的轨迹 .dat到trp格式# 2012.2.8 scott #  影像与轨迹不同步，轨迹晚于视频开始时间，解决: 读取卡内 mov的创建时间和访问时间来判断mov开始和停止时间； #  轨迹自动补偿缺失的秒轨迹点#  在trp同级目录下记录 对应文件名的附属信息 file001.trp -> file001.attr#   file001.attr :   第一行unix timestamp 开始到结束#       12008788213-21321321321#		2011-01-12 12:12:10 - 2011-01-12 12:12:15#  # 看一下dat与mov是否创建时间一致#2012.2.10 4:14 scott# 1. 修改逻辑，通过读取文件最后写入时间和ffmpeg获取视频时常来推断创建时间，并匹配上gps轨迹#     如轨迹前、后、中间出现空隙就自动补全，以秒为单位 import sys,os,os.path,time,struct,traceback,threading,datetime,copyfromdir=''todir=''SUBDIR_MOVIE = '100MEDIA'SUBDIR_GPS = 'INFO'allgps=[]	def decode_line(line):	line = line.strip()	pp = line.split('\t')				if pp[0] !='[G]':		return {}	if len(pp) !=6:		return {}	lat,lon,ymdhms,speed,angle =  pp[2],pp[3],pp[1],pp[4],pp[5]		lat = float(lat[1:])*3600	lon = float(lon[1:])*3600	speed = float(speed)	angle = float(angle)		tt = time.strptime(ymdhms,'%Y-%m-%d %H:%M:%S')	#ymdhms = ymdhms.replace('-','').replace(' ','').replace(':','')			tick = time.mktime(tt)	tick = int(tick)	tp = tt	tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)					return {'tick':tick,'lat':lat,'lon':lon,'speed':speed,'angle':angle,'timestr':tstr}def readImageTimes(imagefile,ffmpeg=''):	import re		rst = () # (creattime,lastmodifytime) timestamp time ticks	detail = os.popen3('%s -i %s'%(ffmpeg,imagefile) )[2].read()	tt = re.findall('Duration: (\d{1,2}:\d{1,2}:\d{1,2}\.\d{0,4}),',detail,re.M)	if tt:		tt = tt[0]	else:		return ()	h,m,s = map(int, map(float,tt.split(':')) )	duration_secs =  int ( h*3600 + m * 60 + s)	lastmodify = os.path.getmtime(imagefile)	createsecs =  lastmodify - duration_secs	return (int(createsecs),int(lastmodify))def gps_smooth(gpslist):	rst	 = []	for g in gpslist:		if not rst: 			rst.append(g)			continue		for tick in range( rst[-1]['tick']+1,g['tick']):			gg = copy.deepcopy(rst[-1])			gg['tick'] = tick			tp = time.localtime(tick)			tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)						gg['timestr']=tstr			rst.append(gg)		rst.append(g)		#print 'smooth:',rst[0]['tick'],rst[-1]['tick'], rst[-1]['tick'] - rst[0]['tick']	return rst									#从轨迹列表中根据文件时间提取gps时间，并进行补偿	def extract_gpsdata(filename):	global allgps		gpslist = allgps		gpsdata=[]	times = readImageTimes(filename,'ffmpeg.exe')	if not times:		print 'illegal file(skipped):',filename		return ()		ctsec,mtsec = times	#ct = time.localtime(ctsec)	#mt = time.localtime(mtsec)	dursec = mtsec - ctsec	#find first matched item	#print gpslist[0],gpslist[-1], mtsec,dursec	tick = gpslist[0]['tick']	#print tick,gpslist[-1]['tick'],mtsec,dursec	if tick < mtsec:			'''		if tick - mtsec > 3600: #隔得时间过长，直接忽略			print " gpstime range did not covered file's modify time!",filename			return ()		'''		if ctsec < tick:			ref = gpslist[0]					g = copy.deepcopy(ref)			g['tick'] = ctsec			tp = time.localtime(g['tick'])			tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)						g['timestr']=tstr						gpslist.insert(0,g)				if gpslist[-1]['tick'] < mtsec:			ref = gpslist[-1]					g = copy.deepcopy(ref)			g['tick'] = mtsec			tp = time.localtime(g['tick'])			tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)						g['timestr']=tstr			gpslist.append(g)			else:		return ()			allgps = gps_smooth(gpslist)		gpslist = allgps	#print gpslist[0],gpslist[-1]			for n in range(len(gpslist)):				g = gpslist[n]		if g['tick'] == mtsec:					#print n,n-dursec			gpsdata = gpslist[n:n-dursec:-1]			gpsdata.reverse()						#print type(gpsdata),type(gpslist[0])			gpsdata.insert(0,gpslist[n-dursec])									break					return gpsdata		def do_convert(targetdir,outputdir=''):	'''		gpsdir - 轨迹数据目录		outputdir - 输出trp目录	'''	global allgps	if not outputdir:		outputdir = targetdir	gpsdir = targetdir +'/' + SUBDIR_GPS	movdir = targetdir + '/' + SUBDIR_MOVIE		#1.检索所有的有效轨迹	files = os.listdir(gpsdir)		for file in files:		name,ext = os.path.splitext(file)		if ext.lower() != '.dat':			continue				filename = gpsdir+"/"+file		fh = open(filename)		lines = fh.readlines()		fh.close()		print filename						#开始解析gps轨迹				pps =[]		for line in lines:			gps = decode_line(line)			if gps:				allgps.append(gps)	# ending read gps files	# sort 	allgps.sort(cmp=lambda x,y:cmp(x['tick'],y['tick']) )	#填充,使之以秒为间隔	#allgps = gps_smooth(allgps)	#process movies file individually	files = os.listdir(movdir)	for file in files:		name,ext = os.path.splitext(file)		if ext.lower() != '.mov':			continue				filename = movdir+"/"+file		gpslist = extract_gpsdata(filename)				#写入trp文件,如果轨迹为空则不产生trp		outfile = gpsdir+"/"+name+".trp"				#print gpslist				print outfile		if gpslist:			f = open(outfile,'w')						for g in gpslist:											pass				#print '--',type(g),g				#print "%.06f,%.06f,%s\n"%(g['lon'],g['lat'],g['timestr'])								f.write( "%.06f,%.06f,%s\n"%(g['lon'],g['lat'],g['timestr']))			f.close()						#				if __name__=='__main__':	if len(sys.argv) ==1:		print 'usage: gs600_trp.py gpsdir [trpdir]'	else:		do_convert(sys.argv[1])			