# -*- coding:utf-8 -*-#2012.2.3 scott   #转换 gs600行车记录仪 的轨迹 .dat到trp格式# 2012.2.8 scott #  影像与轨迹不同步，轨迹晚于视频开始时间，解决: 读取卡内 mov的创建时间和访问时间来判断mov开始和停止时间； #  轨迹自动补偿缺失的秒轨迹点#  在trp同级目录下记录 对应文件名的附属信息 file001.trp -> file001.attr#   file001.attr :   第一行unix timestamp 开始到结束#       12008788213-21321321321#		2011-01-12 12:12:10 - 2011-01-12 12:12:15#  # 看一下dat与mov是否创建时间一致#2012.2.10 4:14 scott# 1. 修改逻辑，通过读取文件最后写入时间和ffmpeg获取视频时常来推断创建时间，并匹配上gps轨迹#     如轨迹前、后、中间出现空隙就自动补全，以秒为单位 import sys,os,os.path,time,struct,traceback,threading,datetime,copyfromdir=''todir=''SUBDIR_MOVIE = '100MEDIA'SUBDIR_GPS = 'INFO'allgps=[]'''def front_pad(pps,st):	if not pps: #轨迹 [G]为空		return []	pp = pps[0]	lines =[]	lat,lon,ymdhms = pp[2],pp[3],pp[1]	tt = time.strptime(ymdhms,'%Y-%m-%d %H:%M:%S')	ymdhms = ymdhms.replace('-','').replace(' ','').replace(':','')		tick = time.mktime(tt)	tick = int(tick)	for t in range(st,tick):		tp = time.localtime(t)		tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)					line  = "%.06f,%.06f,%s"%(lon,lat,tstr) 		lines.append( line)	return lines			#尾部填充	def tail_pad(pps,et):	if not pps:		return []	pp = pps[-1] #最后一个轨迹点	lines =[]	lat,lon,ymdhms = pp[2],pp[3],pp[1]	tt = time.strptime(ymdhms,'%Y-%m-%d %H:%M:%S')	ymdhms = ymdhms.replace('-','').replace(' ','').replace(':','')		tick = time.mktime(tt)	tick = int(tick)	for t in range(tick+1,et+1):		tp = time.localtime(t)		tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)					line  = "%.06f,%.06f,%s"%(lon,lat,tstr) 		lines.append( line)	return linesdef encode_lines(lat,lon,ymdhms,speed=0,angle=0):	global lasttick	lines =[]	lat = float(lat[1:])*3600	lon = float(lon[1:])*3600		tt = time.strptime(ymdhms,'%Y-%m-%d %H:%M:%S')	ymdhms = ymdhms.replace('-','').replace(' ','').replace(':','')		tick = time.mktime(tt)	tick = int(tick)	if lasttick != 0 and tick - lasttick > 1: #两条记录时间过大,填补最近一次gps坐标		for t in range( lasttick+1,tick):			tp = time.localtime(t)			tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)						line  = "%.06f,%.06f,%s"%(lon,lat,tstr) 			lines.append( line)				lasttick = tick		line = "%.06f,%.06f,%s"%(lon,lat,ymdhms)	lines.append(line)	return lines'''	def decode_line(line):	line = line.strip()	pp = line.split('\t')				if pp[0] !='[G]':		return {}	if len(pp) !=6:		return {}	lat,lon,ymdhms,speed,angle =  pp[2],pp[3],pp[1],pp[4],pp[5]		lat = float(lat[1:])*3600	lon = float(lon[1:])*3600	speed = float(speed)	angle = float(angle)		tt = time.strptime(ymdhms,'%Y-%m-%d %H:%M:%S')	#ymdhms = ymdhms.replace('-','').replace(' ','').replace(':','')			tick = time.mktime(tt)	tick = int(tick)	tp = tt	tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)					return {'tick':tick,'lat':lat,'lon':lon,'speed':speed,'angle':angle,'timestr':tstr}def readImageTimes(imagefile,ffmpeg='ffmpeg.exe'):	import re		rst = () # (creattime,lastmodifytime) timestamp time ticks	detail = os.popen3('%s -i %s'%(ffmpeg,imagefile) )[2].read()	tt = re.findall('Duration: (\d{1,2}:\d{1,2}:\d{1,2}\.\d{0,4}),',detail,re.M)	if tt:		tt = tt[0]	else:		return ()	h,m,s = map(int, map(float,tt.split(':')) )	duration_secs =  int ( h*3600 + m * 60 + s)	lastmodify = os.path.getmtime(imagefile)	createsecs =  lastmodify - duration_secs	return (int(createsecs),int(lastmodify))def gps_smooth(gpslist):	rst	 = []	for g in gpslist:		if not rst: 			rst.append(g)			continue		for tick in range( rst[-1]['tick']+1,g['tick']):			gg = copy.deepcopy(rst[-1])			gg['tick'] = tick			tp = time.localtime(tick)			tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)						gg['timestr']=tstr			rst.append(gg)		rst.append(g)		#print 'smooth:',rst[0]['tick'],rst[-1]['tick'], rst[-1]['tick'] - rst[0]['tick']	return rst									#从轨迹列表中根据文件时间提取gps时间，并进行补偿	def extract_gpsdata(filename):	global allgps		gpslist = allgps		gpsdata=[]	times = readImageTimes(filename,'ffmpeg.exe')	if not times:		print 'illegal file(skipped):',filename		return ()		ctsec,mtsec = times	#ct = time.localtime(ctsec)	#mt = time.localtime(mtsec)	dursec = mtsec - ctsec	#find first matched item	#print gpslist[0],gpslist[-1], mtsec,dursec	tick = gpslist[0]['tick']	#print tick,gpslist[-1]['tick'],mtsec,dursec	if tick < mtsec:			'''		if tick - mtsec > 3600: #隔得时间过长，直接忽略			print " gpstime range did not covered file's modify time!",filename			return ()		'''		if ctsec < tick:			ref = gpslist[0]					g = copy.deepcopy(ref)			g['tick'] = ctsec			tp = time.localtime(g['tick'])			tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)						g['timestr']=tstr						gpslist.insert(0,g)				if gpslist[-1]['tick'] < mtsec:			ref = gpslist[-1]					g = copy.deepcopy(ref)			g['tick'] = mtsec			tp = time.localtime(g['tick'])			tstr = "%04d%02d%02d%02d%02d%02d"%(tp.tm_year,tp.tm_mon,tp.tm_mday,tp.tm_hour,tp.tm_min,tp.tm_sec)						g['timestr']=tstr			gpslist.append(g)			else:		return ()			allgps = gps_smooth(gpslist)		gpslist = allgps	#print gpslist[0],gpslist[-1]			for n in range(len(gpslist)):				g = gpslist[n]		if g['tick'] == mtsec:					#print n,n-dursec			gpsdata = gpslist[n:n-dursec:-1]			gpsdata.reverse()						#print type(gpsdata),type(gpslist[0])			gpsdata.insert(0,gpslist[n-dursec])									break					return gpsdata		def do_convert(targetdir,outputdir=''):	'''		gpsdir - 轨迹数据目录		outputdir - 输出trp目录	'''	global allgps	if not outputdir:		outputdir = targetdir	gpsdir = targetdir +'/' + SUBDIR_GPS	movdir = targetdir + '/' + SUBDIR_MOVIE		#1.检索所有的有效轨迹	files = os.listdir(gpsdir)		for file in files:		name,ext = os.path.splitext(file)		if ext.lower() != '.dat':			continue		mov =  movdir + "/" + name + '.mov'		if not os.path.exists(mov):			continue		csec,msec = readImageTimes(mov)		if csec == 0: #视频无法解码			continue		dat = gpsdir+"/"+file		fh = open(dat)		lines = fh.readlines()		fh.close()		print dat						#开始解析gps轨迹		gpslist=[]		pps =[]		for line in lines:			gps = decode_line(line)			if gps:				gpslist.append(gps)		#根据mov长度填充gps空缺记录		if len(gpslist) < 4:			continue		h = gpslist[0]		t = gpslist[-1]		for n in range(csec,h['tick']):			gpslist.insert(0,h)		for n in range(t['tick'],msec):			gpslist.append(t)		#两端补齐之后，中间进行平滑		gpslist = gps_smooth(gpslist)		trp = movdir+"/"+name+".trp"		print trp		if gpslist:			f = open(trp,'w')			for g in gpslist:				f.write( "%.06f,%.06f,%s,%s,%.02f,%.02f\n"%(g['lon'],g['lat'],g['timestr'],g['tick'],g['speed'],g['angle']))			f.close()		#				if __name__=='__main__':	if len(sys.argv) ==1:		print 'usage: gs600_trp.py gpsdir [trpdir]'	else:		do_convert(sys.argv[1])			